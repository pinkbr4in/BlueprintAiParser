# --- START OF FILE nodes.py ---

import re
from typing import List, Dict, Optional, Any, Tuple, Union

# --- Use relative imports ---
from .utils import extract_simple_name_from_path, extract_member_name # Import needed utility

# --- Debug Flag ---
ENABLE_NODE_DEBUG = False # Set to True for verbose node creation/fallback info

# --- Pin Class ---
class Pin:
    """Represents a single pin on a Blueprint node."""
    def __init__(self, pin_id: str, node_guid: str):
        self.id: str = pin_id
        self.node_guid: str = node_guid # GUID of the node this pin belongs to
        self.name: Optional[str] = None
        self.friendly_name: Optional[str] = None
        self.direction: Optional[str] = None # EGPD_Output or EGPD_Input
        self.category: Optional[str] = None # exec, bool, int, real, object, struct, etc.
        self.sub_category: Optional[str] = None # float, double, class name for objects
        self.sub_category_object: Optional[str] = None # Path to object/struct/enum type
        self.is_reference: bool = False
        self.is_const: bool = False
        self.container_type: Optional[str] = None # None (single value), Array, Set, Map
        self.default_value: Optional[str] = None # Stored as string representation from text
        self.autogenerated_default_value: Optional[str] = None # Store autogenerated default
        self.default_object: Optional[str] = None
        self.default_struct: Optional[Dict[str, Any]] = None # Parsed struct default if complex
        self.linked_to_guids: List[Tuple[str, str]] = [] # Raw parsed links (TargetNodeName/GUID, TargetPinID)
        self.raw_properties: Dict[str, Any] = {} # Stores all parsed properties for this pin

        # --- Populated during link resolution ---
        self.linked_pins: List['Pin'] = [] # Pins this pin connects TO (Output -> Input)
        self.source_pin_for: List['Pin'] = [] # Pins that link TO this pin (Input <- Output)

    def is_output(self) -> bool:
        return self.direction == "EGPD_Output"

    def is_input(self) -> bool:
        return self.direction != "EGPD_Output" # Covers EGPD_Input and None

    def is_execution(self) -> bool:
        return self.category == "exec"

    def is_hidden(self) -> bool:
        hidden_val = self.raw_properties.get("bHidden", False)
        if isinstance(hidden_val, str): return hidden_val.lower() == 'true'
        return bool(hidden_val)

    def is_advanced_view(self) -> bool:
        adv_val = self.raw_properties.get("bAdvancedView", False)
        if isinstance(adv_val, str): return adv_val.lower() == 'true'
        return bool(adv_val)

    def get_clean_category(self) -> str:
        cat = self.category or "unknown"
        if self.sub_category_object:
            # Use helper function from utils (already imported)
            name = extract_simple_name_from_path(self.sub_category_object)
            return name if name else cat # Fallback to category if path extraction fails
        elif self.sub_category and self.sub_category != cat:
            # Provide more specific type if available (e.g., "float" for category "real")
            return self.sub_category
        return cat

    def get_type_signature(self) -> str:
        base_type = self.get_clean_category()
        if self.container_type and self.container_type != "None":
            if self.container_type == "Map":
                # TODO: Need to parse PinValueType for Map keys/values if possible
                key_type = "?"
                value_type = base_type
                return f"Map<{key_type}, {value_type}>"
            return f"{self.container_type}<{base_type}>"
        ref_str = "&" if self.is_reference else ""
        const_str = "const " if self.is_const else ""
        return f"{const_str}{base_type}{ref_str}"

    def __repr__(self):
        link_count = len(self.linked_pins)
        source_count = len(self.source_pin_for)
        linked_str = f"LinksOut={link_count}" if self.is_output() else f"LinksIn={source_count}"
        hidden_str = "(H)" if self.is_hidden() else ""
        adv_str = "(A)" if self.is_advanced_view() else ""
        dir_str = "Out" if self.is_output() else "In"
        node_guid_short = f"{self.node_guid[:4]}.." if self.node_guid else "NoNode"
        pin_id_short = f"{self.id[:4]}.." if self.id else "NoID"
        type_sig = self.get_type_signature()
        default_str = f" Def='{str(self.default_value)[:10]}...'" if self.default_value else ""
        return f"Pin(Name='{self.name}', ID='{pin_id_short}', Node='{node_guid_short}', Dir='{dir_str}', Type='{type_sig}' {linked_str}{default_str} {hidden_str}{adv_str})"

# --- Node Base Class ---
class Node:
    """Base class for all Blueprint nodes."""
    def __init__(self, guid: str, node_type: str):
        self.guid: str = guid
        self.node_type: str = node_type # Short, readable type name
        self.ue_class: Optional[str] = None # Full Unreal Engine class path
        self.name: Optional[str] = None # Node's Name property (often unique identifier)
        self.position: Tuple[int, int] = (0, 0)
        self.pins: Dict[str, Pin] = {} # Pin ID -> Pin object
        self.raw_properties: Dict[str, Any] = {}
        self.node_comment: Optional[str] = None # Comment directly on the node
        self.function_name: Optional[str] = None # For CallFunction, Operators
        self.variable_name: Optional[str] = None # For VariableGet/Set
        self.custom_function_name: Optional[str] = None # For CustomEvent
        self.event_function_name: Optional[str] = None # For standard Event nodes
        self.delegate_name: Optional[str] = None # For Delegate nodes
        self.macro_graph_path: Optional[str] = None # For MacroInstance
        self.is_latent: bool = False # Flag for latent actions
        self.self_context: bool = True # Assume self context by default (relevant for var/func calls)
        self.is_pure_call: bool = False # For function/macro nodes

    def is_pure(self) -> bool:
        """Checks if the node acts as a pure node (no execution pins or explicitly marked pure)."""
        # Check explicit flags first
        if self.is_pure_call: return True
        # Check based on node type (some are always pure)
        if isinstance(self, (K2Node_VariableGet, K2Node_MakeStruct, K2Node_BreakStruct, K2Node_Select,
                              K2Node_PromotableOperator, K2Node_CommutativeAssociativeBinaryOperator,
                              K2Node_GetClassDefaults, K2Node_MakeArray, K2Node_MakeMap,
                              K2Node_GetArrayItem, K2Node_CreateDelegate, K2Node_Literal)): # Added Literal
            return True
        # Check if it has *any* execution pins
        return not any(pin.is_execution() for pin in self.pins.values())


    def get_pin(self, pin_name: Optional[str] = None, pin_id: Optional[str] = None) -> Optional[Pin]:
        if pin_id: return self.pins.get(pin_id)
        if pin_name:
            pin_name_lower = pin_name.lower()
            # Iterate to find by name (exact match first)
            for pin in self.pins.values():
                if pin.name == pin_name: return pin
            # Case-insensitive fallback
            for pin in self.pins.values():
                if pin.name and pin.name.lower() == pin_name_lower: return pin
                # Check friendly name as fallback
                if pin.friendly_name and pin.friendly_name.lower() == pin_name_lower: return pin
        return None

    def find_pin(self, name_substring: str, direction: Optional[str] = None, category: Optional[str] = None) -> Optional[Pin]:
        """Finds a pin whose name contains the substring, optionally filtering by direction/category."""
        name_sub_lower = name_substring.lower()
        for pin in self.pins.values():
            pin_matches = False
            if pin.name and name_sub_lower in pin.name.lower(): pin_matches = True
            elif pin.friendly_name and name_sub_lower in pin.friendly_name.lower(): pin_matches = True

            if pin_matches:
                if direction is not None and pin.direction != direction: continue
                if category is not None and pin.category != category: continue
                return pin
        return None

    def get_execution_output_pin(self, pin_name: str = "then") -> Optional[Pin]:
        """Gets a specific or the 'primary' output execution pin."""
        # Prioritize requested pin name if it's an output exec pin
        requested_pin = self.get_pin(pin_name=pin_name)
        if requested_pin and requested_pin.is_output() and requested_pin.is_execution():
            return requested_pin

        # Try common primary output names next
        primary_names = ["then", "trigger", "completed", "loopbody", "exit", "success", "is valid", "a", "pressed", "released", "update"]
        for name in primary_names:
            pin = self.get_pin(pin_name=name)
            if pin and pin.is_execution() and pin.is_output():
                return pin

        # Fallback: find the first visible output execution pin, sorted alphabetically
        output_exec_pins = sorted(
            [p for p in self.pins.values() if p.is_execution() and p.is_output() and not p.is_hidden() and not p.is_advanced_view()],
            key=lambda p: p.name or ""
        )
        if output_exec_pins:
            return output_exec_pins[0]

        # Fallback 2: find any output execution pin (including hidden/advanced)
        all_output_exec = sorted(
            [p for p in self.pins.values() if p.is_execution() and p.is_output()],
            key=lambda p: p.name or ""
        )
        return all_output_exec[0] if all_output_exec else None

    def get_execution_input_pin(self) -> Optional[Pin]:
        """Gets the primary input execution pin."""
        # Try common primary input names first
        primary_names = ["execute", "exec", "in", "run", "tryget", "enter", "play", "playfromstart", "cast", "bind", "add", "assign", "set", "spawnactor", "create", "remove", "clear"]
        for name in primary_names:
            pin = self.get_pin(pin_name=name)
            if pin and pin.is_execution() and pin.is_input(): return pin

        # Fallback: find the first input execution pin, sorted alphabetically
        input_exec_pins = sorted(
            [p for p in self.pins.values() if p.is_execution() and p.is_input()],
             key=lambda p: p.name or ""
        )
        return input_exec_pins[0] if input_exec_pins else None

    def get_output_pins(self, category: Optional[str] = None, include_hidden: bool = False, name_regex: Optional[str]=None) -> List[Pin]:
        pins = []
        regex = re.compile(name_regex) if name_regex else None
        for pin in self.pins.values():
            if pin.is_output() and (include_hidden or not (pin.is_hidden() or pin.is_advanced_view())):
                if category is None or pin.category == category:
                    if regex is None or (pin.name and regex.match(pin.name)):
                        pins.append(pin)
        pins.sort(key=lambda p: p.name or "")
        return pins

    def get_input_pins(self, category: Optional[str] = None, include_hidden: bool = False, exclude_exec: bool = True) -> List[Pin]:
        pins = []
        for pin in self.pins.values():
            if pin.is_input():
                # Skip if hidden/advanced unless include_hidden is True
                if not include_hidden and (pin.is_hidden() or pin.is_advanced_view()):
                    continue
                # Skip execution pins if excluded
                if exclude_exec and pin.is_execution(): continue
                # Check category if specified
                if category is None or pin.category == category: pins.append(pin)
        # Sort primarily by non-advanced, then by name
        pins.sort(key=lambda p: (1 if p.is_advanced_view() else 0, p.name or ""))
        return pins

    def to_dict(self) -> Dict[str, Any]:
        """Serializes the node and its pins to a dictionary."""
        return {
            "guid": self.guid,
            "type": self.node_type,
            "name": self.name,
            "ue_class": self.ue_class,
            "position": self.position,
            "comment": self.node_comment,
            "properties": self.raw_properties, # Include raw for debug/completeness
            "pins": [
                {
                    "id": pin.id,
                    "name": pin.name,
                    "friendly_name": pin.friendly_name,
                    "direction": pin.direction,
                    "type_sig": pin.get_type_signature(),
                    "default_value": pin.default_value,
                    "default_object": pin.default_object,
                    "default_struct": pin.default_struct,
                    "is_hidden": pin.is_hidden(),
                    "is_advanced": pin.is_advanced_view(),
                    # Keep raw linked guids for external verification if needed
                    "linked_to_guids": pin.linked_to_guids,
                    # Represent actual links by Pin ID for internal consistency
                    "linked_pin_ids": [p.id for p in pin.linked_pins],
                    "source_pin_ids": [p.id for p in pin.source_pin_for],
                    # "raw_pin_properties": pin.raw_properties # Optional: for full debug
                } for pin in self.pins.values()
            ]
        }

    def __repr__(self):
        pin_count = len(self.pins)
        guid_short = f"{self.guid[:8]}" if self.guid else "NoGUID"
        name_str = f", Name='{self.name}'" if self.name and self.name != self.node_type else ""
        comment_str = f", Comment='{self.node_comment[:20]}...'" if self.node_comment else ""
        return f"{self.node_type}(GUID='{guid_short}'{name_str}{comment_str}, Pins={pin_count})"

# --- Specific Node Subclasses ---
# (Keep most subclasses as they add type safety and specific helper methods)
# ... (Existing Subclasses like EdGraphNode_Comment, K2Node_CustomEvent, K2Node_Event, etc.) ...
class EdGraphNode_Comment(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "Comment")
        self.comment_text: Optional[str] = None
        self.comment_color: Optional[str] = None
        self.NodeWidth: int = 500
        self.NodeHeight: int = 300
    @property
    def node_comment(self): return self.comment_text
    @node_comment.setter
    def node_comment(self, value): self.comment_text = value

class K2Node_CustomEvent(Node):
    def __init__(self, guid: str): super().__init__(guid, "CustomEvent")
    def get_delegate_output_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="OutputDelegate")
class K2Node_Event(Node):
    def __init__(self, guid: str): super().__init__(guid, "Event")

class K2Node_VariableSet(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "VariableSet")
        self.variable_type: Optional[str] = None
        # variable_name is set in base class parsing

    def get_value_input_pin(self) -> Optional[Pin]:
        """Gets the primary data input pin (the value to set the variable to)."""
        if self.variable_name:
            pin_by_name = self.get_pin(pin_name=self.variable_name)
            if pin_by_name and pin_by_name.is_input() and not pin_by_name.is_execution(): return pin_by_name
        # Fallback: Search common names or the first non-self, non-exec input
        common_input_names = ["Value", "InputPin"]
        for name in common_input_names:
            pin = self.get_pin(pin_name=name)
            if pin and pin.is_input() and not pin.is_execution(): return pin

        sorted_pins = self.get_input_pins(exclude_exec=True)
        return next((p for p in sorted_pins if p.name not in ['self', 'Target', '__WorldContext', 'WorldContextObject']), None)

    def get_value_output_pin(self) -> Optional[Pin]:
        """Gets the passthrough output pin."""
        return self.get_pin(pin_name="Output_Get") or self.get_pin(pin_name=self.variable_name)

    def get_target_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="self") or self.get_pin(pin_name="Target")


class K2Node_VariableGet(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "VariableGet")
        self.variable_type: Optional[str] = None
        # variable_name is set in base class parsing

    def get_value_output_pin(self) -> Optional[Pin]:
        """Gets the primary data output pin."""
        if self.variable_name:
            pin_by_name = self.get_pin(pin_name=self.variable_name)
            if pin_by_name and pin_by_name.is_output() and not pin_by_name.is_execution(): return pin_by_name
        # Fallback: Find the first non-self, non-exec output pin
        sorted_pins = self.get_output_pins(include_hidden=False)
        return next((p for p in sorted_pins if p.name not in ['self', '__WorldContext', 'WorldContextObject']), None)

    def get_target_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="self") or self.get_pin(pin_name="Target")


class K2Node_CallFunction(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "CallFunction")
        # is_pure_call set by base parser
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="self") or self.get_pin(pin_name="Target")
    def get_return_value_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="ReturnValue")
    def __repr__(self):
        pin_count = len(self.pins)
        guid_short = f"{self.guid[:8]}" if self.guid else "NoGUID"
        func_str = f", Func='{self.function_name}'" if self.function_name else ""
        pure_str = " (Pure)" if self.is_pure_call else ""
        latent_str = " (Latent)" if self.is_latent else ""
        return f"{self.node_type}(GUID='{guid_short}'{func_str}{pure_str}{latent_str}, Pins={pin_count})"

class K2Node_MacroInstance(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "MacroInstance")
        self.macro_type: Optional[str] = None # Holds the 'pretty' name (e.g., FlipFlop, ForLoop)
        # is_pure_macro set by base parser
    def __repr__(self):
        pin_count = len(self.pins)
        guid_short = f"{self.guid[:8]}" if self.guid else "NoGUID"
        macro_name = self.macro_type or "Unknown"
        macro_str = f", Macro='{macro_name}'"
        pure_str = " (Pure)" if self.is_pure() else ""
        return f"{self.node_type}(GUID='{guid_short}'{macro_str}{pure_str}, Pins={pin_count})"

class K2Node_IfThenElse(Node):
    def __init__(self, guid: str): super().__init__(guid, "IfThenElse")
    def get_condition_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Condition")
    def get_true_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="then")
    def get_false_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="else")

class K2Node_ExecutionSequence(Node):
    def __init__(self, guid: str): super().__init__(guid, "ExecutionSequence")
    def get_execution_output_pins(self) -> List[Pin]:
        outputs = []
        i = 0
        while True:
            pin = self.get_pin(pin_name=f"then_{i}")
            if pin and pin.is_execution() and pin.is_output(): outputs.append(pin); i += 1
            else: break
        if not outputs: outputs = sorted([p for p in self.pins.values() if p.is_execution() and p.is_output()], key=lambda p: p.name or "")
        return outputs

class K2Node_Knot(Node):
    def __init__(self, guid: str, node_type="Knot"): super().__init__(guid, node_type)
    def get_passthrough_input_pin(self) -> Optional[Pin]:
        inputs = [p for p in self.pins.values() if p.is_input()]
        return inputs[0] if inputs else self.get_pin(pin_name="InputPin")
    def get_passthrough_output_pin(self) -> Optional[Pin]:
        outputs = [p for p in self.pins.values() if p.is_output()]
        return outputs[0] if outputs else self.get_pin(pin_name="OutputPin")
    def get_execution_output_pin(self, pin_name: str = "") -> Optional[Pin]:
        pin = self.get_passthrough_output_pin()
        return pin if pin and pin.is_execution() else None
    def get_execution_input_pin(self) -> Optional[Pin]:
        pin = self.get_passthrough_input_pin()
        return pin if pin and pin.is_execution() else None

class K2Node_PromotableOperator(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "PromotableOperator")
        self.operation_name: Optional[str] = None
    def get_input_pins(self, include_hidden: bool = False, exclude_exec: bool = True) -> List[Pin]:
        inputs = super().get_input_pins(include_hidden=include_hidden, exclude_exec=exclude_exec)
        standard_input_names = {'A', 'B', 'C', 'D', 'E', 'Index'}
        inputs.sort(key=lambda p: (0 if p.name in standard_input_names else 1, p.name or ""))
        return inputs
    def get_output_pin(self) -> Optional[Pin]:
        pin = self.get_pin(pin_name="ReturnValue")
        if pin and pin.is_output() and not pin.is_execution(): return pin
        return next((p for p in self.get_output_pins() if not p.is_execution() and p.name != 'self'), None)

class K2Node_CommutativeAssociativeBinaryOperator(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "CommutativeAssociativeBinaryOperator")
        self.operation_name: Optional[str] = None
    def get_input_pins(self, include_hidden: bool = False, exclude_exec: bool = True) -> List[Pin]:
        inputs = super().get_input_pins(include_hidden=include_hidden, exclude_exec=exclude_exec)
        standard_input_names = {'A', 'B', 'C', 'D', 'E'}
        inputs.sort(key=lambda p: (0 if p.name in standard_input_names else 1, p.name or ""))
        return inputs
    def get_output_pin(self) -> Optional[Pin]:
        pin = self.get_pin(pin_name="ReturnValue")
        if pin and pin.is_output() and not pin.is_execution(): return pin
        return next((p for p in self.get_output_pins() if not p.is_execution() and p.name != 'self'), None)

class K2Node_CallDelegate(Node):
    def __init__(self, guid: str): super().__init__(guid, "CallDelegate")
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="self")
    def get_delegate_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Delegate") # Pin connected TO this node's exec

class K2Node_AssignDelegate(Node):
    def __init__(self, guid: str): super().__init__(guid, "AssignDelegate")
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="self")
    def get_delegate_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Delegate") # Input pin connected TO Custom Event or Create Delegate

class K2Node_AddDelegate(Node):
    def __init__(self, guid: str): super().__init__(guid, "AddDelegate") # Standard 'Bind Event' node
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="self")
    def get_delegate_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Delegate") # Input pin connected TO Custom Event or Create Delegate

class K2Node_RemoveDelegate(Node):
    def __init__(self, guid: str): super().__init__(guid, "RemoveDelegate")
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="self")
    def get_delegate_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Delegate") # Input pin connected TO Custom Event or Create Delegate

class K2Node_ClearDelegate(Node):
    def __init__(self, guid: str): super().__init__(guid, "ClearDelegate")
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="self")

class K2Node_CreateDelegate(Node):
    def __init__(self, guid: str): super().__init__(guid, "CreateDelegate")
    def get_object_pin(self) -> Optional[Pin]: return self.get_pin("Object")
    def get_function_name_pin(self) -> Optional[Pin]: return self.get_pin("FunctionName") # Name input pin
    def get_delegate_output_pin(self) -> Optional[Pin]: return self.get_pin("ReturnValue") # Output pin

class K2Node_EnhancedInputAction(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "EnhancedInputAction")
        self.input_action_path: Optional[str] = None
        self.input_action_name: Optional[str] = None
    def get_execution_output_pins(self) -> List[Pin]:
        outputs = []
        common_names = ["Triggered", "Started", "Ongoing", "Canceled", "Completed"]
        found_pins = set()
        for name in common_names:
            pin = self.get_pin(pin_name=name)
            if pin and pin.is_execution() and pin.is_output():
                outputs.append(pin)
                found_pins.add(pin.id)
        for pin in self.pins.values():
            if pin.id not in found_pins and pin.is_execution() and pin.is_output():
                outputs.append(pin)
                found_pins.add(pin.id)
        outputs.sort(key=lambda p: (common_names.index(p.name) if p.name in common_names else 99, p.name or ""))
        return outputs
    def get_execution_output_pin(self, pin_name: str = "Triggered") -> Optional[Pin]:
        if pin_name == "then": pin_name = "Triggered" # Treat 'then' as 'Triggered'
        pin = self.get_pin(pin_name=pin_name)
        if pin and pin.is_execution() and pin.is_output(): return pin
        triggered_pin = self.get_pin(pin_name="Triggered")
        if triggered_pin and triggered_pin.is_execution() and triggered_pin.is_output(): return triggered_pin
        all_outputs = self.get_execution_output_pins()
        return all_outputs[0] if all_outputs else None
    def get_execution_input_pin(self) -> Optional[Pin]: return None # Events don't have input exec
    def get_action_value_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Action Value") or self.get_pin(pin_name="ActionValue")
    def get_elapsed_seconds_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Elapsed Time") or self.get_pin(pin_name="ElapsedSeconds")
    def get_triggered_seconds_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Triggered Time") or self.get_pin(pin_name="TriggeredSeconds")

class K2Node_InputAxisEvent(Node):
    def __init__(self, guid: str): super().__init__(guid, "InputAxisEvent")
    def get_axis_value_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Axis Value") or self.get_pin(pin_name="AxisValue")
class K2Node_InputAction(Node):
    def __init__(self, guid: str): super().__init__(guid, "InputAction")
    def get_pressed_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Pressed")
    def get_released_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Released")
    def get_key_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Key")
class K2Node_InputKey(Node):
    def __init__(self, guid: str): super().__init__(guid, "InputKey")
    def get_pressed_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Pressed")
    def get_released_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Released")
    def get_key_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Key") # Output pin
class K2Node_InputTouch(Node):
    def __init__(self, guid: str): super().__init__(guid, "InputTouch")
    def get_pressed_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Pressed")
    def get_released_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Released")
    def get_location_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Location")
    def get_finger_index_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Finger Index")
class K2Node_InputAxisKeyEvent(Node):
    def __init__(self, guid: str): super().__init__(guid, "InputAxisKeyEvent")
    def get_axis_value_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Axis Value") or self.get_pin(pin_name="AxisValue")
class K2Node_InputDebugKey(Node):
    def __init__(self, guid: str): super().__init__(guid, "InputDebugKey")
    def get_pressed_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Pressed")
    def get_released_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Released")

class K2Node_FlipFlop(Node):
    def __init__(self, guid: str): super().__init__(guid, "FlipFlop")
    def get_a_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="A")
    def get_b_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="B")
    def get_is_a_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="IsA")

class K2Node_DynamicCast(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "DynamicCast")
        self.target_type: Optional[str] = None
    def get_object_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="ObjectToCast") or self.get_pin(pin_name="Object")
    def get_success_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="then")
    def get_failed_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="CastFailed")
    def get_as_pin(self) -> Optional[Pin]:
        if self.target_type:
            base_name = self.target_type.replace(' ', '')
            possible_names = [f"As {self.target_type}", f"As{base_name}"] # Check both space and no space
            for name in possible_names:
                pin = self.get_pin(pin_name=name)
                if pin and pin.is_output() and pin.category == "object": return pin
        return next((p for p in self.get_output_pins(category="object") if p.name != "Success" and "As" in (p.friendly_name or p.name or "")), None) or \
               next((p for p in self.get_output_pins(category="object") if p.name != "Success"), None) # Fallback if As... not found


class K2Node_Timeline(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "Timeline")
        self.timeline_name: Optional[str] = None
        self.is_latent = True # Timelines are always latent
    def get_play_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Play")
    def get_play_from_start_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="PlayFromStart")
    def get_stop_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Stop")
    def get_reverse_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Reverse")
    def get_reverse_from_end_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="ReverseFromEnd")
    def get_update_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Update")
    def get_finished_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Finished")
    def get_track_pins(self) -> List[Pin]:
        return [p for p in self.get_output_pins() if p.name not in ["Update", "Finished", "Direction"]]

class K2Node_MakeStruct(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "MakeStruct")
        self.struct_type: Optional[str] = None
    def get_output_struct_pin(self) -> Optional[Pin]:
        if self.struct_type:
            struct_name_short = extract_simple_name_from_path(self.struct_type) or self.struct_type
            pin = self.get_pin(pin_name=struct_name_short)
            if pin and pin.is_output(): return pin
        return next((p for p in self.get_output_pins() if p.category == "struct"), None)

class K2Node_BreakStruct(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "BreakStruct")
        self.struct_type: Optional[str] = None
    def get_input_struct_pin(self) -> Optional[Pin]:
        if self.struct_type:
            struct_name_short = extract_simple_name_from_path(self.struct_type) or self.struct_type
            pin = self.get_pin(pin_name=struct_name_short)
            if pin and pin.is_input(): return pin
        return next((p for p in self.get_input_pins() if p.category == "struct" and not p.is_hidden()), None)

class K2Node_SetFieldsInStruct(Node):
    def __init__(self, guid: str): super().__init__(guid, "SetFieldsInStruct")
    def get_input_struct_pin(self) -> Optional[Pin]: return self.get_pin("StructRef") # Often pin name
    def get_struct_pin(self) -> Optional[Pin]: return self.get_pin("StructRef") # Alias
    def get_output_struct_pin(self) -> Optional[Pin]: return self.get_pin("Result")

class K2Node_Select(Node):
    def __init__(self, guid: str): super().__init__(guid, "Select")
    def get_index_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Index") or self.get_pin(pin_name="Condition")
    def get_option_pins(self) -> List[Pin]:
        options = []
        i = 0
        while True:
            pin = self.get_pin(pin_name=f"Option {i}")
            if pin and pin.is_input(): options.append(pin); i += 1
            else: break
        if not options: options = [p for p in self.get_input_pins(exclude_exec=True, include_hidden=True) if p.name not in ["Index", "Condition", "self"]]
        return options
    def get_return_value_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="ReturnValue")

class K2Node_Switch(Node):
    def __init__(self, guid: str, node_type:str ="Switch"): super().__init__(guid, node_type)
    def get_selection_pin(self) -> Optional[Pin]: return self.get_pin("Selection")
    def get_default_pin(self) -> Optional[Pin]: return self.get_pin("Default")
    def get_case_pins(self) -> List[Pin]:
        return sorted([p for p in self.get_output_pins(category="exec") if p.name != "Default"], key=lambda p: p.friendly_name or p.name or "")

class K2Node_SwitchEnum(K2Node_Switch):
    def __init__(self, guid: str): super().__init__(guid, "SwitchEnum")
class K2Node_SwitchName(K2Node_Switch):
    def __init__(self, guid: str): super().__init__(guid, "SwitchName")
class K2Node_SwitchString(K2Node_Switch):
    def __init__(self, guid: str): super().__init__(guid, "SwitchString")
class K2Node_SwitchInteger(K2Node_Switch):
    def __init__(self, guid: str): super().__init__(guid, "SwitchInteger")

class K2Node_ForEachLoop(Node):
    def __init__(self, guid: str): super().__init__(guid, "ForEachLoop")
    def get_array_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Array")
    def get_loop_body_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="LoopBody")
    def get_array_element_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Array Element")
    def get_array_index_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Array Index")
    def get_completed_pin(self) -> Optional[Pin]: return self.get_pin(pin_name="Completed")

class K2Node_CallParentFunction(Node):
    def __init__(self, guid: str): super().__init__(guid, "CallParentFunction")

class K2Node_FunctionEntry(Node):
    def __init__(self, guid: str): super().__init__(guid, "FunctionEntry")
class K2Node_FunctionResult(Node):
    def __init__(self, guid: str): super().__init__(guid, "FunctionResult")
    def get_return_value_pin(self) -> Optional[Pin]: return self.get_pin("ReturnValue") # Usually named this

class K2Node_Tunnel(Node):
    def __init__(self, guid: str): super().__init__(guid, "Tunnel")

# --- NEW: K2Node_Literal ---
class K2Node_Literal(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "Literal")
    def get_output_pin(self) -> Optional[Pin]:
        # Literals typically have one unnamed output pin or named "ReturnValue"
        pin = self.get_pin(pin_name="ReturnValue")
        if pin and pin.is_output(): return pin
        return next((p for p in self.pins.values() if p.is_output()), None)

# --- MODIFIED: K2Node_Composite ---
class K2Node_Composite(Node):
     def __init__(self, guid: str):
         super().__init__(guid, "Composite")
         self.bound_graph_name: Optional[str] = None # To store the name

class K2Node_LatentAction(Node):
    def __init__(self, guid: str, node_type:str="LatentAction"):
        super().__init__(guid, node_type)
        self.is_latent = True
    def get_completed_pin(self) -> Optional[Pin]: return self.get_pin("Completed") or self.get_pin("then")

class K2Node_PlayMontage(K2Node_LatentAction):
    def __init__(self, guid: str): super().__init__(guid, "PlayMontage")
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin("Target")
    def get_montage_to_play_pin(self) -> Optional[Pin]: return self.get_pin("MontageToPlay")
    def get_play_rate_pin(self) -> Optional[Pin]: return self.get_pin("PlayRate")
    def get_start_position_pin(self) -> Optional[Pin]: return self.get_pin("StartingPosition")
    def get_start_section_pin(self) -> Optional[Pin]: return self.get_pin("StartingSection")
    def get_on_completed_pin(self) -> Optional[Pin]: return self.get_pin("OnCompleted")
    def get_on_blend_out_pin(self) -> Optional[Pin]: return self.get_pin("OnBlendOut")
    def get_on_interrupted_pin(self) -> Optional[Pin]: return self.get_pin("OnInterrupted")
    def get_on_notify_begin_pin(self) -> Optional[Pin]: return self.get_pin("OnNotifyBegin")
    def get_on_notify_end_pin(self) -> Optional[Pin]: return self.get_pin("OnNotifyEnd")

# --- MODIFIED: K2Node_CallArrayFunction ---
class K2Node_CallArrayFunction(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "CallArrayFunction")
        self.array_function_name: Optional[str] = None # Ensure this exists
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin("Target Array")
    def get_item_pin(self) -> Optional[Pin]: return self.get_pin("Item") or self.get_pin("item to find") or self.get_pin("New Item")
    def get_index_pin(self) -> Optional[Pin]: return self.get_pin("Index")
    # Add getters for common array function outputs
    def get_return_value_pin(self) -> Optional[Pin]: return self.get_pin("ReturnValue") # For functions like Length, Get, Find
    def get_output_array_pin(self) -> Optional[Pin]: return self.get_pin("Output Array") # For functions like Set, Add, Insert, Remove

class K2Node_GetArrayItem(Node):
    def __init__(self, guid: str): super().__init__(guid, "GetArrayItem")
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin("Target Array")
    def get_index_pin(self) -> Optional[Pin]: return self.get_pin("Dimension 1") or self.get_pin("Index")
    def get_output_item_pin(self) -> Optional[Pin]: return self.get_pin("Output") or self.get_pin("ReturnValue")

class K2Node_MakeArray(Node):
    def __init__(self, guid: str): super().__init__(guid, "MakeArray")
    def get_item_pins(self) -> List[Pin]: return sorted([p for p in self.pins.values() if p.name.startswith('[') and p.is_input()], key=lambda p: int(p.name[1:-1]))
    def get_output_array_pin(self) -> Optional[Pin]: return self.get_pin("Array")

class K2Node_MakeMap(Node):
    def __init__(self, guid: str): super().__init__(guid, "MakeMap")
    def get_item_pins(self) -> List[Tuple[Optional[Pin], Optional[Pin]]]:
        pairs = []
        i = 0
        while True:
            key_pin = self.get_pin(f"Key {i}")
            val_pin = self.get_pin(f"Value {i}")
            if key_pin and val_pin: pairs.append((key_pin, val_pin)); i += 1
            else: break
        return pairs
    def get_output_map_pin(self) -> Optional[Pin]: return self.get_pin("Map")

class K2Node_FormatText(Node):
    def __init__(self, guid: str): super().__init__(guid, "FormatText")
    def get_format_pin(self) -> Optional[Pin]: return self.get_pin("Format")
    def get_argument_pins(self) -> List[Pin]: return sorted([p for p in self.get_input_pins() if p.name != "Format"], key=lambda p: p.name or "")
    def get_result_pin(self) -> Optional[Pin]: return self.get_pin("Result")

# --- START MODIFIED NODE SUBCLASSES (already present in base code) ---
class K2Node_SpawnActorFromClass(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "SpawnActorFromClass")
        self.spawn_class_path: Optional[str] = None # Added during parsing
    def get_class_pin(self) -> Optional[Pin]: return self.get_pin("Class")
    def get_spawn_transform_pin(self) -> Optional[Pin]: return self.get_pin("SpawnTransform")
    def get_collision_handling_pin(self) -> Optional[Pin]: return self.get_pin("CollisionHandlingOverride")
    def get_owner_pin(self) -> Optional[Pin]: return self.get_pin("Owner")
    def get_return_value_pin(self) -> Optional[Pin]: return self.get_pin("ReturnValue")
    # --- NEW HELPER ---
    def get_spawn_class_name(self) -> Optional[str]:
        """Attempts to get the simple name of the class being spawned."""
        class_pin = self.get_class_pin()
        if class_pin and class_pin.default_object:
            return extract_simple_name_from_path(class_pin.default_object)
        if self.spawn_class_path:
            return extract_simple_name_from_path(self.spawn_class_path)
        return None

class K2Node_AddComponent(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "AddComponent")
        self.component_class_path: Optional[str] = None # Added during parsing
    def get_target_pin(self) -> Optional[Pin]: return self.get_pin("Target")
    def get_component_class_pin(self) -> Optional[Pin]: return self.get_pin("ComponentClass") # Changed from "Class" to "ComponentClass"
    def get_return_value_pin(self) -> Optional[Pin]: return self.get_pin("ReturnValue")
    # --- NEW HELPER ---
    def get_component_class_name(self) -> Optional[str]:
        """Attempts to get the simple name of the component being added."""
        class_pin = self.get_component_class_pin()
        if class_pin and class_pin.default_object:
            return extract_simple_name_from_path(class_pin.default_object)
        # Fallback using TemplateType or TemplateBlueprint if available in raw_properties
        template_type = self.raw_properties.get("TemplateType")
        if template_type:
            return extract_simple_name_from_path(str(template_type))
        template_bp = self.raw_properties.get("TemplateBlueprint")
        if template_bp:
            return extract_simple_name_from_path(str(template_bp))
        if self.component_class_path:
            return extract_simple_name_from_path(self.component_class_path)
        return None

class K2Node_CreateWidget(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "CreateWidget")
        self.widget_class_path: Optional[str] = None # Added during parsing
    def get_owning_player_pin(self) -> Optional[Pin]: return self.get_pin("OwningPlayer")
    def get_widget_class_pin(self) -> Optional[Pin]: return self.get_pin("Class") # Original uses "Class" pin name
    def get_return_value_pin(self) -> Optional[Pin]: return self.get_pin("ReturnValue")
    # --- NEW HELPER ---
    def get_widget_class_name(self) -> Optional[str]:
        """Attempts to get the simple name of the widget being created."""
        class_pin = self.get_widget_class_pin()
        if class_pin and class_pin.default_object:
            return extract_simple_name_from_path(class_pin.default_object)
        if self.widget_class_path:
            return extract_simple_name_from_path(self.widget_class_path)
        return None

class K2Node_GenericCreateObject(Node):
    def __init__(self, guid: str): super().__init__(guid, "GenericCreateObject")
    def get_class_pin(self) -> Optional[Pin]: return self.get_pin("Class")
    def get_outer_pin(self) -> Optional[Pin]: return self.get_pin("Outer")
    def get_return_value_pin(self) -> Optional[Pin]: return self.get_pin("ReturnValue")

class K2Node_GetSubsystem(Node):
    def __init__(self, guid: str, node_type="GetSubsystem"):
        super().__init__(guid, node_type)
        self.subsystem_class_path: Optional[str] = None # Added during parsing
    def get_class_pin(self) -> Optional[Pin]: return self.get_pin("Class") # Often hidden
    def get_return_value_pin(self) -> Optional[Pin]: return self.get_pin("ReturnValue")
    # --- NEW HELPER ---
    def get_subsystem_class_name(self) -> Optional[str]:
        """Attempts to get the simple name of the subsystem being retrieved."""
        if self.subsystem_class_path:
            return extract_simple_name_from_path(self.subsystem_class_path)
        # Fallback check from raw CustomClass property if parsing missed it
        custom_class = self.raw_properties.get("CustomClass")
        if custom_class:
            return extract_simple_name_from_path(str(custom_class))
        # Fallback check from ReturnValue pin type if needed
        ret_pin = self.get_return_value_pin()
        if ret_pin and ret_pin.sub_category_object:
            return extract_simple_name_from_path(ret_pin.sub_category_object)
        return None

class K2Node_GetEngineSubsystem(K2Node_GetSubsystem):
    def __init__(self, guid: str): super().__init__(guid, "GetEngineSubsystem")
class K2Node_GetSubsystemFromPC(K2Node_GetSubsystem):
    def __init__(self, guid: str): super().__init__(guid, "GetSubsystemFromPC")
    def get_player_controller_pin(self) -> Optional[Pin]: return self.get_pin("PlayerController")

class K2Node_GetClassDefaults(Node):
    def __init__(self, guid: str):
        super().__init__(guid, "GetClassDefaults")
        self.target_class_path: Optional[str] = None # Added during parsing
    def get_output_pins(self, category: Optional[str] = None, include_hidden: bool = False) -> List[Pin]:
        return [p for p in super().get_output_pins(category, include_hidden) if p.name != 'self']
    # --- NEW HELPER ---
    def get_target_class_name(self) -> Optional[str]:
        """Attempts to get the simple name of the target class."""
        if self.target_class_path:
            return extract_simple_name_from_path(self.target_class_path)
        # Fallback: Try finding first output pin's object type
        first_out = next((p for p in self.get_output_pins() if p.sub_category_object), None)
        if first_out and first_out.sub_category_object:
            return extract_simple_name_from_path(first_out.sub_category_object)
        return None
# --- END MODIFIED NODE SUBCLASSES ---

# --- NEW: Bound Event Nodes ---
class K2Node_ComponentBoundEvent(Node):
     def __init__(self, guid: str):
         super().__init__(guid, "ComponentBoundEvent")
         self.component_property_name: Optional[str] = None
         self.delegate_property_name: Optional[str] = None
         self.delegate_owner_class: Optional[str] = None # Store the class path

class K2Node_ActorBoundEvent(Node):
     def __init__(self, guid: str):
         super().__init__(guid, "ActorBoundEvent")
         self.delegate_property_name: Optional[str] = None
         self.event_owner = None # Can store actor ref if needed/parsable

class NiagaraNodeReroute(K2Node_Knot):
    def __init__(self, guid: str): super().__init__(guid, "NiagaraReroute")

# --- Node Factory Map (Updated and Expanded) ---
NODE_TYPE_MAP: Dict[str, type[Node]] = {
    # --- Core Blueprint Nodes (Specific Classes) ---
    "/Script/UnrealEd.EdGraphNode_Comment": EdGraphNode_Comment,
    "/Script/BlueprintGraph.K2Node_CustomEvent": K2Node_CustomEvent,
    "/Script/BlueprintGraph.K2Node_Event": K2Node_Event,
    "/Script/BlueprintGraph.K2Node_VariableSet": K2Node_VariableSet,
    "/Script/BlueprintGraph.K2Node_VariableGet": K2Node_VariableGet,
    "/Script/BlueprintGraph.K2Node_CallFunction": K2Node_CallFunction,
    "/Script/BlueprintGraph.K2Node_MacroInstance": K2Node_MacroInstance,
    "/Script/BlueprintGraph.K2Node_IfThenElse": K2Node_IfThenElse,
    "/Script/BlueprintGraph.K2Node_ExecutionSequence": K2Node_ExecutionSequence,
    "/Script/BlueprintGraph.K2Node_Knot": K2Node_Knot,
    "/Script/BlueprintGraph.K2Node_PromotableOperator": K2Node_PromotableOperator,
    "/Script/BlueprintGraph.K2Node_CommutativeAssociativeBinaryOperator": K2Node_CommutativeAssociativeBinaryOperator,
    "/Script/BlueprintGraph.K2Node_CallDelegate": K2Node_CallDelegate,
    "/Script/BlueprintGraph.K2Node_AssignDelegate": K2Node_AssignDelegate,
    "/Script/BlueprintGraph.K2Node_AddDelegate": K2Node_AddDelegate,
    "/Script/BlueprintGraph.K2Node_RemoveDelegate": K2Node_RemoveDelegate,
    "/Script/BlueprintGraph.K2Node_ClearDelegate": K2Node_ClearDelegate,
    "/Script/BlueprintGraph.K2Node_CreateDelegate": K2Node_CreateDelegate,
    "/Script/BlueprintGraph.K2Node_Timeline": K2Node_Timeline,
    "/Script/BlueprintGraph.K2Node_MakeStruct": K2Node_MakeStruct,
    "/Script/BlueprintGraph.K2Node_BreakStruct": K2Node_BreakStruct,
    "/Script/BlueprintGraph.K2Node_SetFieldsInStruct": K2Node_SetFieldsInStruct,
    "/Script/BlueprintGraph.K2Node_Select": K2Node_Select,
    "/Script/BlueprintGraph.K2Node_SwitchEnum": K2Node_SwitchEnum,
    "/Script/BlueprintGraph.K2Node_SwitchName": K2Node_SwitchName,
    "/Script/BlueprintGraph.K2Node_SwitchString": K2Node_SwitchString,
    "/Script/BlueprintGraph.K2Node_SwitchInteger": K2Node_SwitchInteger,
    "/Script/BlueprintGraph.K2Node_ForEachLoop": K2Node_ForEachLoop,
    "/Script/BlueprintGraph.K2Node_FlipFlop": K2Node_FlipFlop,
    "/Script/BlueprintGraph.K2Node_CallParentFunction": K2Node_CallParentFunction,
    "/Script/BlueprintGraph.K2Node_FunctionEntry": K2Node_FunctionEntry,
    "/Script/BlueprintGraph.K2Node_FunctionResult": K2Node_FunctionResult,
    "/Script/BlueprintGraph.K2Node_Tunnel": K2Node_Tunnel,
    "/Script/BlueprintGraph.K2Node_Composite": K2Node_Composite, # Keep Composite
    "/Script/BlueprintGraph.K2Node_DynamicCast": K2Node_DynamicCast,
    "/Script/BlueprintGraph.K2Node_MakeArray": K2Node_MakeArray,
    "/Script/BlueprintGraph.K2Node_GetArrayItem": K2Node_GetArrayItem,
    "/Script/BlueprintGraph.K2Node_CallArrayFunction": K2Node_CallArrayFunction, # Keep Array Function
    "/Script/BlueprintGraph.K2Node_FormatText": K2Node_FormatText,
    "/Script/BlueprintGraph.K2Node_MakeMap": K2Node_MakeMap,
    "/Script/BlueprintGraph.K2Node_GetClassDefaults": K2Node_GetClassDefaults, # Keep Class Defaults
    "/Script/BlueprintGraph.K2Node_SpawnActorFromClass": K2Node_SpawnActorFromClass,
    "/Script/BlueprintGraph.K2Node_AddComponent": K2Node_AddComponent,
    "/Script/UMGEditor.K2Node_CreateWidget": K2Node_CreateWidget,
    "/Script/BlueprintGraph.K2Node_GenericCreateObject": K2Node_GenericCreateObject,
    "/Script/AnimGraph.K2Node_PlayMontage": K2Node_PlayMontage,
    "/Script/BlueprintGraph.K2Node_GetEngineSubsystem": K2Node_GetEngineSubsystem,
    "/Script/BlueprintGraph.K2Node_GetSubsystem": K2Node_GetSubsystem,
    "/Script/BlueprintGraph.K2Node_GetSubsystemFromPC": K2Node_GetSubsystemFromPC,
    # Input Nodes
    "/Script/InputBlueprintNodes.K2Node_EnhancedInputAction": K2Node_EnhancedInputAction,
    "/Script/BlueprintGraph.K2Node_InputAxisEvent": K2Node_InputAxisEvent,
    "/Script/BlueprintGraph.K2Node_InputAction": K2Node_InputAction,
    "/Script/BlueprintGraph.K2Node_InputKey": K2Node_InputKey,
    "/Script/BlueprintGraph.K2Node_InputTouch": K2Node_InputTouch,
    "/Script/BlueprintGraph.K2Node_InputAxisKeyEvent": K2Node_InputAxisKeyEvent,
    "/Script/BlueprintGraph.K2Node_InputDebugKey": K2Node_InputDebugKey,

    # Map specific reroutes to appropriate classes
    "/Script/UnrealEd.MaterialGraphNode_Knot": K2Node_Knot,
    "/Script/NiagaraEditor.NiagaraNodeReroute": NiagaraNodeReroute,

    # --- NEW MAPPINGS ---
    "/Script/BlueprintGraph.K2Node_Literal": K2Node_Literal, # Add Literal
    "/Script/BlueprintGraph.K2Node_ComponentBoundEvent": K2Node_ComponentBoundEvent, # Add Bound Event
    "/Script/BlueprintGraph.K2Node_ActorBoundEvent": K2Node_ActorBoundEvent, # Add Bound Event
    # --- END NEW ---

    # --- Map remaining specialized types to the base Node class ---
    # (This relies on create_node_instance determining the node_type string)
    # Material Editor
    "/Script/UnrealEd.MaterialGraphNode_Root": Node,
    "/Script/UnrealEd.MaterialGraphNode": Node,
    "/Script/Engine.MaterialExpression": Node, # Catch all MaterialExpression base

    # --- Animation Editor Nodes (Mapped to Generic Node) ---
    "/Script/AnimGraph.AnimGraphNode_Root": Node,
    "/Script/AnimGraph.AnimGraphNode_StateMachine": Node,
    "/Script/AnimGraph.AnimStateNode": Node,
    "/Script/AnimGraph.AnimStateEntryNode": Node,
    "/Script/AnimGraph.AnimStateTransitionNode": Node,
    "/Script/AnimGraph.AnimGraphNode_Slot": Node,
    "/Script/AnimGraph.AnimGraphNode_UseCachedPose": Node,
    "/Script/AnimGraph.AnimGraphNode_SaveCachedPose": Node,
    "/Script/AnimGraph.AnimGraphNode_BlendListByBool": Node,
    "/Script/AnimGraph.AnimGraphNodeBinding_Base": Node,

    # Metasound Editor
    "/Script/MetasoundEditor.": Node, # Catch all Metasound nodes

    # Niagara Editor
    "/Script/NiagaraEditor.": Node, # Catch all Niagara nodes (except Reroute)

    # PCG Editor
    "/Script/PCGEditor.": Node, # Catch all PCG nodes

    # Behavior Tree Editor
    "/Script/AIGraph.": Node, # Catch all AIGraph nodes

    # Other K2Nodes mapped generically for now
    #"/Script/BlueprintGraph.K2Node_Literal": Node, # Now mapped specifically
    "/Script/BlueprintGraph.K2Node_Self": Node,
    "/Script/BlueprintGraph.K2Node_ConvertAsset": Node,
    "/Script/BlueprintGraph.K2Node_EnumEquality": Node,
    "/Script/BlueprintGraph.K2Node_EnumInequality": Node,
    "/Script/BlueprintGraph.K2Node_GetEnumeratorNameAsString": Node,
    "/Script/BlueprintGraph.K2Node_CastByteToEnum": Node,

    # Map various latent action types to a base LatentAction class
    "/Script/BlueprintGraph.K2Node_LatentOnlineCall": K2Node_LatentAction,
    "/Script/BlueprintGraph.K2Node_LatentGameplayTaskCall": K2Node_LatentAction,
    "/Script/BlueprintGraph.K2Node_AsyncAction": K2Node_LatentAction,
    "/Script/AIGraph.K2Node_AIMoveTo": K2Node_LatentAction,

    # Other common nodes
    #"/Script/BlueprintGraph.K2Node_ComponentBoundEvent": Node, # Now mapped specifically
    #"/Script/BlueprintGraph.K2Node_ActorBoundEvent": Node, # Now mapped specifically
}

def create_node_instance(guid: str, class_path: str) -> Node:
    """
    Factory function to create specific Node instances based on the UE class path.
    Falls back to the base Node class if the type is unknown or unsupported.
    """
    matched_class = Node
    longest_match = ""
    for pattern, node_cls in NODE_TYPE_MAP.items():
        if class_path.startswith(pattern):
            if len(pattern) > len(longest_match):
                longest_match = pattern
                matched_class = node_cls

    node_class = matched_class
    node_type_str = ""

    # Use predefined type for known classes
    try:
        temp_instance = node_class(guid, "TempType") if node_class in [K2Node_Switch, K2Node_LatentAction, K2Node_GetSubsystem, K2Node_Knot] else node_class(guid)
        node_type_str = temp_instance.node_type
    except Exception:
        node_type_str = "" # Will generate below

    # Generate readable name if not obtained or if generic
    if not node_type_str:
        node_type_str = class_path.split('.')[-1] if '.' in class_path else class_path
        node_type_str = node_type_str.split('/')[-1]
        prefixes_to_remove = [
            "K2Node_", "EdGraphNode_", "MaterialGraphNode_", "AnimGraphNode_",
            "BehaviorTreeGraphNode_", "NiagaraNode", "MetasoundEditorGraph", "PCGEditorGraphNode"
        ]
        for prefix in prefixes_to_remove:
            if node_type_str.startswith(prefix):
                node_type_str = node_type_str[len(prefix):]
                break
        if node_type_str.startswith("MaterialExpression"): node_type_str = f"MatExp_{node_type_str[18:]}"
        if node_class == Node and ENABLE_NODE_DEBUG: print(f"DEBUG: Created generic Node instance for class: {class_path} -> Type: {node_type_str}")

    # Instantiate correctly
    instance: Node
    try:
        if node_class == Node: instance = Node(guid, node_type_str)
        elif node_class in [K2Node_Switch, K2Node_LatentAction, K2Node_GetSubsystem, K2Node_Knot]: instance = node_class(guid, node_type_str)
        else: instance = node_class(guid)
    except Exception as e:
        print(f"Error: Unexpected error instantiating {node_class.__name__} for {guid}: {e}. Falling back to base Node.")
        node_type_str = class_path.split('.')[-1].replace("K2Node_", "").replace("EdGraphNode_", "")
        instance = Node(guid, node_type_str)

    instance.ue_class = class_path
    if not instance.node_type: instance.node_type = node_type_str # Ensure node_type is set

    return instance

# --- END OF FILE nodes.py ---