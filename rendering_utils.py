# rendering_utils.py
import re
import uuid
import markdown # Requires 'pip install markdown'
import bleach    # Requires 'pip install bleach'
from markupsafe import Markup
import logging   # Use standard logging
import html      # For html.escape

# ==============================================================================
# Helper Functions (Moved from routes.py)
# ==============================================================================

def html_escape(text: str) -> str:
    """Escapes text for use in HTML attribute values or content."""
    if not text:
        return ""
    # Use standard library html.escape for robust escaping
    return html.escape(text, quote=True)

def clean_html_entities(html_content: str) -> str:
    """Normalize common HTML entities to prevent double escaping."""
    # Be careful with order if adding more complex entities
    replacements = [
        ('&lt;', '<'), ('&gt;', '>'), ('&quot;', '"'),
        ('&#39;', "'"), ('&amp;', '&') # Ampersand last
    ]
    if not isinstance(html_content, str):
        return str(html_content) # Return string representation of non-strings
    cleaned = html_content
    for old, new in replacements:
        cleaned = cleaned.replace(old, new)
    return cleaned

def blueprint_markdown(text: str, logger: logging.Logger) -> Markup:
    """
    Convert markdown text containing potential ```blueprint``` blocks to
    sanitized HTML Markup, preserving the content of blueprint blocks.
    Accepts a logger instance for error reporting.
    """
    if not text:
        return Markup("")

    local_placeholder_storage = {}
    def replace_blueprint_block(match):
        """Replaces ```blueprint block with a placeholder."""
        block_content = match.group(1)
        placeholder_uuid = str(uuid.uuid4())
        # Use a unique HTML comment as placeholder
        placeholder_comment = f"<!-- BP_PLACEHOLDER_{placeholder_uuid} -->"
        local_placeholder_storage[placeholder_comment] = block_content
        return placeholder_comment

    # Replace blueprint blocks before markdown processing
    text_with_placeholders = re.sub(
        r'```blueprint\r?\n(.*?)\r?\n```', replace_blueprint_block, text,
        flags=re.DOTALL | re.IGNORECASE
    )

    # Process with standard Markdown library
    try:
        rendered_html = markdown.markdown(
            text_with_placeholders,
            extensions=['markdown.extensions.tables', 'markdown.extensions.fenced_code', 'markdown.extensions.nl2br']
        )
    except Exception as e:
        logger.error(f"Error during markdown conversion: {e}", exc_info=True)
        # Escape the error message for safe HTML display
        return Markup(f"<p>Error during Markdown processing: {html_escape(str(e))}</p>")

    # Restore blueprint blocks (now embedded within potentially generated HTML)
    for placeholder, bp_content in local_placeholder_storage.items():
        # Escape the raw blueprint content before wrapping in <pre><code>
        escaped_bp_content = html_escape(bp_content)
        # Create the final HTML structure for the blueprint block
        blueprint_html_block = f'<pre class="blueprint"><code class="nohighlight blueprint-code" data-nohighlight="true">{Markup(escaped_bp_content)}</code></pre>'
        # Replace the placeholder comment with the generated HTML block
        rendered_html = rendered_html.replace(placeholder, blueprint_html_block)

    # Process tables generated by markdown
    rendered_html = process_blueprint_tables(rendered_html, logger) # Pass logger

    # Sanitize the final HTML
    allowed_tags = bleach.sanitizer.ALLOWED_TAGS | {
        'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'br', 'hr', 'strong', 'em',
        'ul', 'ol', 'li', 'pre', 'code', 'span', 'div', 'a', 'img', 'table',
        'thead', 'tbody', 'tr', 'th', 'td', 'blockquote',
        # Ensure pre, code, span are allowed for blueprint blocks
    }
    allowed_attrs = {
        # Allow common attributes on all tags
        '*': ['class', 'id', 'style', 'data-nohighlight'],
        'a': ['href', 'title', 'target'], # Removed id, class as they are in '*'
        'img': ['src', 'alt', 'title', 'width', 'height'],
        'code': ['class', 'data-nohighlight'], # Already covered by '*' but explicit
        'pre': ['class'], # Already covered by '*'
        'span': ['class', 'style'], # Already covered by '*'
        'td': ['colspan', 'rowspan'], # Style/class covered by '*'
        'th': ['colspan', 'rowspan'], # Style/class covered by '*'
        'div': ['class', 'style', 'id'] # Already covered by '*'
    }
    try:
        # Ensure input to bleach is a string
        clean_html = bleach.clean(str(rendered_html), tags=allowed_tags, attributes=allowed_attrs, strip=True)
        # Clean common entities that might remain or be introduced by bleach/markdown
        clean_html = clean_html_entities(clean_html)
    except Exception as e:
        logger.error(f"Error during HTML sanitization: {e}", exc_info=True)
        clean_html = f"<p>Error during HTML sanitization: {html_escape(str(e))}</p>"

    # Return Markup object, indicating the string is safe for rendering
    return Markup(clean_html)


def process_blueprint_tables(html: str, logger: logging.Logger) -> str:
    """Adds 'blueprint-table' class to tables found in the HTML."""
    if not isinstance(html, str):
        return str(html) # Return string representation if not string

    table_pattern = r'(<table.*?>)(.*?)(</table>)' # Capture opening tag separately
    def process_table_match(match):
        opening_tag = match.group(1)
        table_content = match.group(2)
        closing_tag = match.group(3)

        new_opening_tag = opening_tag
        # Add class safely, checking if class attribute already exists
        if 'class=' in opening_tag.lower():
             # Use regex to insert class name carefully
             new_opening_tag = re.sub(r'(class\s*=\s*["\'])(.*?)', r'\1blueprint-table \2', opening_tag, flags=re.IGNORECASE)
        else:
             # Add new class attribute
             new_opening_tag = opening_tag.rstrip(' >') + ' class="blueprint-table">'

        # Add function-table class if applicable (simple check)
        if '<th>Function</th>' in table_content and '<th>Target</th>' in table_content:
            if 'class="blueprint-table"' in new_opening_tag:
                new_opening_tag = new_opening_tag.replace('class="blueprint-table"', 'class="blueprint-table function-table"', 1)
            elif 'class=' in new_opening_tag:
                 new_opening_tag = re.sub(r'(class\s*=\s*["\'])(.*?)', r'\1function-table \2', new_opening_tag, flags=re.IGNORECASE)
            else:
                 # This case shouldn't happen if blueprint-table was added above
                 new_opening_tag = new_opening_tag.rstrip(' >') + ' class="function-table">'


        # Optional: Log the modification
        # logger.debug(f"Modified table tag: {opening_tag} -> {new_opening_tag}")

        return new_opening_tag + table_content + closing_tag

    # Use re.sub with the callback function
    try:
        processed_html = re.sub(table_pattern, process_table_match, html, flags=re.IGNORECASE | re.DOTALL)
        return processed_html
    except Exception as e:
        logger.error(f"Error processing blueprint tables: {e}", exc_info=True)
        return html # Return original HTML on error